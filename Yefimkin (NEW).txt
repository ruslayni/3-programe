#include <stdio.h> 
#define MOD 1000000007 // Оголошуємо модуль для обмеження результатів 
#define MAX 31 // Максимальна кількість розрядів 
#define dig 2 // Максимальна кількість послідовних цифр 5 або 9 
 
// Масив для зберігання проміжних результатів 
long long dp[MAX][dig+1][dig+1]; 
 
// Функція для попереднього обчислення результатів 
void precompute() { 
    int i, j, k; 
    // Ініціалізуємо базові випадки 
    dp[1][1][0] = dp[1][0][1] = 1; 
    // Запускаємо цикл по всіх можливих розрядах 
    for(i = 2; i < MAX; i++) { 
        // Запускаємо цикл по всіх можливих позиціях для цифри 5 
        for(j = 0; j <= dig; j++) { 
            // Запускаємо цикл по всіх можливих позиціях для цифри 9 
            for(k = 0; k <= dig; k++) { 
                // Якщо можливо, додаємо цифру 5 
                if(j < dig) dp[i][j+1][0] += dp[i-1][j][k]; 
                // Якщо можливо, додаємо цифру 9 
                if(k < dig) dp[i][0][k+1] += dp[i-1][j][k]; 
                // Виконуємо модулярний обмежувач 
                dp[i][j+1][0] %= MOD; 
                dp[i][0][k+1] %= MOD; 
            } 
        } 
    } 
} 
 
// Функція для обчислення кінцевого результату 
long long int compute(int n) { 
    long long int ans = 0; 
    for(int i = 0; i <= dig; i++) { 
        for(int j = 0; j <= dig; j++) { 
            // Додаємо всі можливі варіанти 
            ans += dp[n][i][j]; 
            // Виконуємо модулярний обмежувач 
            ans %= MOD; 
        } 
    } 
    return ans; 
} 
 
int main() { 
    // Виконуємо попередні обчислення 
    precompute(); 
    int n; 
    printf("Введіть ціле число р (р ≤ 30): "); 
    // Зчитуємо вхідні дані 
    scanf("%d", &n); 
    // Виводимо результат 
    printf("Кількість чисел із %d розрядів: %lld\n", n, compute(n));  
    return 0; 
}